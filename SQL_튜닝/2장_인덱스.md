

수십 년에 걸쳐 DBMS가 발전해왔지만, 테이블의 데이터를 찾는 방법은 여전히 두 가지다.
- 테이블 전체를 스캔한다 -> 다량의 데이터를 검색
- 인덱스를 이용한다 -> 

## SQL 튜닝은 랜덤 I/O와의 전쟁이다
- DBMS가 성능을 위해 제공하는 대부분의 기능들이 느려터진 랜덤 액세스를 극복하기 위한 것일정도로, 랜덤 I/O는 매우 중요하다.

## 
컬럼 A, B에 인덱스가 같이 걸려 있을 때, A-> B 순서로 정렬하여 탐색하는 것과 B->A 순서로 정렬하여 탐색하는 것 중 더 빠른 쪽을 선택한다.

EX. 학생부에 '이름', '시력' 으로 인덱스가 걸려 있을 때, 시력 -> 이름으로 정렬하여 찾는 것이 빠를까? 아니면 이름->시력으로 정렬하여 찾는 것이 빠를까? 
이름이 홍길동인 사람보다 시력이 1.0인 사람이 훨씬 많을 것이므로, 이름 -> 시력 순으로 정렬하면 스캔 범위가 훨씬 빨리 좁혀질 것이다.

## 인덱스 튜닝 핵심 - 2. 랜덤 엑세스 최소화 튜닝 
- 인덱스 스캔 후 발생하는 테이블 레코드 횟수(=랜덤 엑세스 횟수)를 최소화하는 튜닝이다.
- 학생부에 '이름', '시력' 인덱스가 각각 따로 걸려있고, 이름이 홍길동인 사람은 3명, 시력이 1.0인 사람은 50명 이하라면, 이름 인덱스를 사용하는 것이 훨씬 빠르다.

# 
- 인덱스 탐색은 엑셀의 필터 기능과는 다르다. B*-Tree 인덱스는 평면 구조가 아니라 입체 구조이기 때문에 위와 같은 설명은 틀리다.
- 책의 예시에서도 볼 수 있지만, 결합 인덱스를 이름 -> 성별로 구성하든, 성별->이름으로 구성하든 인덱스 블록 수가 같아서 성능이 같은 경우도 발생할 수 있다.
- 인덱스 구성에 따라 성능이 차이가 나는 것은 맞지만, 인터넷에 흔히 돌아다니는 저런 식의 설명은 곤란하다.

# 인덱스 탐색 과정
## 수직적 탐색
- 인덱스 스캔의 시작 지점을 찾는 과정.
- 루트 노드에서 시작해서 조건을 따라 브랜치로 뻗어 나간다.

## 수평적 탐색
- 데이터를 찾는 과정.
- 수직적 탐색을 통해 조건에 맞는 노드(=스캔 시작점)을 찾아내고 나면, 그 노드에 있는 데이터들(=리프 노드)을 수평적으로 스캔함.
