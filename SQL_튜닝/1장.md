

- SQL은 이름에서도 알 수 있듯이 구조적이고, 집합적이고 선언적인 질의언어이다.
- 원하는 결과 집합을 구조적, 집합적으로 선언하지만, 그 결과 집합을 만들어 내기 위해서는 절차적인 과정, 즉 프로시저가 필요하다. 
- 그런 프로시저를 DBMS 내부 엔진인 SQL 옵티마이저가 만들어 낸다.
- 즉, **옵티마이저가 프로그래밍을 대신 해준다.**

# SQL 공유 및 재사용

## 라이브러리 캐시
- 위에서 설명한 SQL 실행과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 **라이브러리 캐시(Libary Cache)**라고 한다.
- SGA(System Global Area)는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간인데, 라이브러리 캐시는 SGA의 구성 요소이다.
![image](https://user-images.githubusercontent.com/15938354/141728450-5a13fbe1-1403-4027-a639-19d86f0d617a.png)

- DBMS는 SQL 파싱 후에 라이브러리 캐시에 프로시저가 있는지 없는지 검사하는데, 이 때 찾아서 곧바로 실행으로 넘어가는 것을 소프트 파싱, 찾는데 실패하여 최적화 과정을 새로 거치는 것을 하드파싱이라 한다.
- SQL 최적화 과정은 한 번 최적화를 하는 데에 모든 실행 계획을 뽑아내고, 시스템 구조, 시스템 통계, 오브젝트 통계, 파라미터 등을 모두 고려하여 하나를 선택하는데, 이 과정은 결코 가벼울 수 없다.
- 즉 SQL 최적화 과정은 무거우며, 이런 과정을 거쳐 만든 프로시저를 캐싱하지 않고 바로 버린다면 효율적이지 않다.

## 바인드 변수의 중요성
- 함수, 프로시저, 패키지, 트리거 등은 각자의 이름을 가지고 있다. 그러나 실행되는 SQL문은 이름이 없고, 전체 SQL 텍스트로 지어진 이름을 가지고 캐싱을 하게 된다. 
- 하드 파싱을 줄이기 위해서는 루틴이 동일한 프로시저에 대해서는 바인드 변수* 을 사용한 파라미터 driven으로 SQL을 설계해야 하며, 이는 SQL 튜닝의 기초이자 기본이다.


# 데이터 저장 구조 및 I/O 메커니즘
### 데이터베이스 저장 구조 
![image](https://user-images.githubusercontent.com/15938354/141728664-759e4b04-4501-42e4-b516-3b0c2941365a.png)

- I/O 튜닝이 곧 SQL 튜닝이다.
- I/O 작업이 일어나는 동안, 프로세스는 잠을 자기 때문이다.
- 즉, SQL 속도를 높이기 위해서는 I/O 시간을 줄여야 한다.

데이터 파일은 디스크 상의 물리적인 os 파일이며, 익스텐트와 블록을 지정하는 파일이다.

# 논리적 I/O vs 물리적 I/O
- 위에서 살펴본 SGA에는 DB 버퍼 캐시라는 공간이 있다. 위에서 말한 라이브러리 캐시가 '코드 캐시'라면, DB 버퍼 캐시에서 필요한 블록을 찾아 리턴한다.
- 이 경우 디스크에서 발
- 메모리 I/O는 전기적 신호인 데 반해, 디스크 I/O는 물리적 작용이다. 디스크 I/O가 메모리 I/에 비해 보통 10000배 쯤 느리다.
- 즉 물리적 I/O 역시 논리적 I/O에 비해 그 만큼 느리다.

버퍼 캐시 히트율이란 버퍼 캐시 효율을 측정하는 데 전통적으로 가장 많이 

# 시퀀셜 액세스 vs 랜덤 엑세스 
- I/O의 최소 단위는 블록이다. 
